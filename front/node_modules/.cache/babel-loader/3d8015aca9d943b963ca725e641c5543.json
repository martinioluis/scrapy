{"ast":null,"code":"import { useEffect, useRef } from 'react';\nimport { useCallbackOne as useCallback, useMemoOne as useMemo } from 'use-memo-one';\nimport { useAsyncTask } from './use-async-task';\nimport { useMemoList } from './utils';\nexport const useAsyncCombineSeq = (...asyncTasks) => {\n  const indexRef = useRef(0);\n  const memoAsyncTasks = useMemoList(asyncTasks, (a, b) => a.start === b.start);\n  const task = useAsyncTask(useCallback(async abortController => {\n    abortController.signal.addEventListener('abort', () => {\n      memoAsyncTasks.forEach(asyncTask => {\n        asyncTask.abort();\n      });\n    }); // start the first one\n\n    memoAsyncTasks[0].start();\n    indexRef.current = 0;\n  }, [memoAsyncTasks]));\n  useEffect(() => {\n    // if current task is finished, start next task\n    const currTask = asyncTasks[indexRef.current];\n    const nextTask = asyncTasks[indexRef.current + 1];\n\n    if (nextTask && currTask && !currTask.pending && !currTask.error) {\n      nextTask.start();\n      indexRef.current += 1;\n    }\n  });\n  const taskPending = asyncTasks.some(({\n    pending\n  }) => pending);\n  const taskError = asyncTasks.find(({\n    error\n  }) => error);\n  const taskErrorAll = useMemoList(asyncTasks.map(({\n    error\n  }) => error));\n  const taskResult = useMemoList(asyncTasks.map(({\n    result\n  }) => result));\n  return useMemo(() => ({\n    start: task.start,\n    abort: task.abort,\n    started: task.started,\n    pending: taskPending,\n    error: taskError,\n    errorAll: taskErrorAll,\n    result: taskResult\n  }), [task.start, task.abort, task.started, taskPending, taskError, taskErrorAll, taskResult]);\n};","map":null,"metadata":{},"sourceType":"module"}