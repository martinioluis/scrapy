{"ast":null,"code":"import { useCallbackOne as useCallback } from 'use-memo-one';\nimport { useAsyncTask } from './use-async-task';\nimport { useAsyncRun } from './use-async-run';\nconst defaultInit = {};\n\nconst defaultReadBody = body => body.json();\n\nconst createFetchError = (message, responseBody) => {\n  const err = new Error(message);\n  err.name = 'FetchError';\n  err.responseBody = responseBody;\n  return err;\n};\n\nconst safeReadBody = async (readBody, response) => {\n  try {\n    return await readBody(response);\n  } catch (e) {\n    return null;\n  }\n};\n\nexport const useAsyncTaskFetch = (input, init = defaultInit, argReadBody) => {\n  // a workaround for terser (#19)\n  const readBody = argReadBody || defaultReadBody;\n  return useAsyncTask(useCallback(async (abortController, inputOverride, initOverride) => {\n    const response = await fetch(inputOverride || input, { ...init,\n      ...initOverride,\n      signal: abortController.signal\n    });\n\n    if (!response.ok) {\n      const responseBody = await safeReadBody(readBody, response);\n      throw createFetchError(response.statusText, responseBody);\n    }\n\n    const body = await readBody(response);\n    return body;\n  }, [input, init, readBody]));\n};\nexport const useFetch = (...args) => {\n  const asyncTask = useAsyncTaskFetch(...args);\n  useAsyncRun(asyncTask);\n  return asyncTask;\n};","map":null,"metadata":{},"sourceType":"module"}